import QNET
import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
import statistics as stats
import scipy.stats as sp
import copy
import random

def percolate(Q, prob, head_tail_method):
    """
    Percolates a graph with some probability, making sure not to remove particular nodes of interest (head, tail)
    :param Q: Qnet Graph
    :param prob: Probability of not removing a given node not in (head, tail)
    :param head: Qnode
    :param tail: Qnode
    :return: Percolated Graph, head node, tail node
    """
    C = copy.deepcopy(Q)
    head, tail = head_tail_method(C)

    kill_list = []
    for node in C.nodes():
        xd = random.uniform(0,1)
        if xd < prob:
            if node not in (head, tail):
                kill_list.append(node)
    C.remove_nodes_from(kill_list)
    return C, head, tail


def monte_method(protocols, head_tail_method, Q, num_iters, num_steps, protocol_kwargs = None, exception_methods = None):
    """
    This function runs a list of protocols against multiples instances of pseudo-random graphs and returns the costs for
    each. The graphs are generated by taking graph Q as an input and randomly percolating it over a range of percolation
    densities. Once the data is collected, it's then processed such that for each protocol and percolation density
    there is an associated mean and variance. Users wishing to visualise this output may do so with plot_monte_method.

    In the event that a path does not exist between the head and tail, no data is added, unless an exception method is
    specified. In the event that only 0 or 1 data point was collected, (Hence either mean or variance is not well
    defined) then the mean and variance are set to zero.

    :param protocols:
    A list of functions that will be used on the percolated graphs. They must each be of the following form:
        function(Q, head, tail, **kwargs)
        Q: Qnet Graph
        head: List of Qnodes
        tail: List of Qnodes
        return: An array of all valid costs in Qnet.
    WARNING: All protocols must return all costs of Qnet in the same order
    # TODO: Might be easier if the protocols instead returned cost vectors.
    :type protocols: list, optional

    :param head_tail_method:
    This is a method for generating two communication parties over which the protocol will take place. It must be of the
    following form:
        function(Q)
        Q: Qnet Graph

    :param Q: The Qnet graph to be percolated
    :param int num_iters: Number of iterations per percolation density
    :param int num_steps: Number of steps in over the percolation density range (0,1)

    :param list protocol_kwargs:
    Optional: A list of dictionaries containing additional keyword arguments for each of the protocols. Hint: Use an
    empty dictionary for protocols that don't have additional kwargs.

    :param list exception_methods:
    Optional: A list of methods for each protocol that handle the event in which no path was found. If method is None,
    only data points from graphs where head and tail are connected are used.

    :return: A two dimensional cost array. The first index is the protocol used, the second is the percolation density.
    Each value is a tuple containing the mean and variance:

    cost_array[protocol_index][percolation_index] = (mean, variance)

    Function Outline:
    1. Percolate lattice
    2. Check that path exists from A to B
    3. Run protocol
    4. Collect data
    5. Repeat until num_iters is reached
    6. Repeat for all protocols
    7. Process data into mean and varience
    """
    if protocol_kwargs is not None:
        assert(len(protocols) == len(protocol_kwargs))

    if exception_methods is not None:
        assert(len(protocols) == len(exception_methods))

    # Range of percolation densities to calculate for
    defect_probs = np.linspace(0, 1, num_steps)

    # Initalize cost_array
    # cost_array == cost_array[cost_type][protocol][num_step]
    cost_array = [[[] for j in range(num_steps)] for k in range(len(protocols))]

    for prob_index in range(num_steps):
        for iter_index in range(num_iters):
            # Percolate the graph and get head - tail nodes
            P, head, tail = percolate(Q, defect_probs[prob_index], head_tail_method)
            assert head is not None and tail is not None

            # If head_tail method returns a list of nodes for head and tail, check they're the same size
            if isinstance(head, list) or isinstance(tail, list):
                assert len(head) == len(tail)

            # Check if paths exist between all head and tail pairs
            paths_exist = True
            if isinstance(head, list) or isinstance(tail, list):
                for i in range(len(head)):
                    if not nx.has_path(P, head[i], tail[i]):
                        paths_exist = False
            else:
                if nx.has_path(P, head, tail) is False:
                    paths_exist = False

            # If paths do exist, run each of the protocols against the graphs
            if paths_exist is True:
                for proto_index in range(len(protocols)):
                    # Get protocol kwargs
                    if protocol_kwargs is not None:
                        kwargs = protocol_kwargs[proto_index]
                    else:
                        kwargs = {}

                    # Get cost_vector from the protocol
                    cost_vector = protocols[proto_index](P, head, tail, **kwargs)
                    # Add the cost vector to the array
                    cost_array[proto_index][prob_index].append(cost_vector)

            # Else if no paths exist between head and tail nodes, try running exception methods
            else:
                if exception_methods is not None:
                    # Run exception_methods for costs
                    for method_index in range(len(exception_methods)):
                        if exception_methods[method_index] is not None:
                            cost_vector = exception_methods[method_index]()
                            # Add cost_vector to the array
                            cost_array[method_index][prob_index].append(cost_vector)

    # Process cost_array such that each data point takes the form (mean, error)
    processed_array = [[{} for i in range(num_steps)] for j in range(len(protocols))]

    for proto_index in range(len(protocols)):
        for prob_index in range(num_steps):

            # Get default cost vector for protocol
            default = protocols[proto_index]()
            # If Mean and error are not well defined, set mean and error to zero
            if len(cost_array[proto_index][prob_index]) in [0,1]:
                for cost in default.keys():
                    processed_array[proto_index][prob_index][cost] = (0, 0)
            else:
                for cost in default.keys():
                    raw = [d[cost] for d in cost_array[proto_index][prob_index]]
                    mean = stats.mean(raw)
                    err = sp.sem(raw)
                    processed_array[proto_index][prob_index][cost] = (mean, err)

    return processed_array


def plot_monte_method(cost_array, protocols, title):

    # num_steps == number of probability densities == x-axis.
    num_steps = len(cost_array[0])
    defect_prob = np.linspace(0, 1, num_steps)  # Range over which Monte-Carlo Iterations runs

    for proto_index in range(len(protocols)):
        # Get costs for a given protocol
        default_vector = protocols[proto_index]()
        for cost in default_vector.keys():
            d_list = cost_array[proto_index]
            avg = [d[cost][0] for d in d_list]
            err = [d[cost][1] for d in d_list]

            # Label the curve with the protocol name and the associated cost type.
            label = protocols[proto_index].__name__ + " " + "(" + str(cost) + ")"
            plt.errorbar(defect_prob, avg, yerr=err, label=label)

    plt.title(title)
    plt.xlabel("Node Deletion Probability")
    plt.ylabel("Protocol Cost")
    plt.legend()
    plt.show()


# Some functions to test out monte_method
def simple_head_tail(P):
    A = P.getNode("A")
    B = P.getNode("B")
    return A, B

def path_exist(P, head, tail):
    if nx.has_path(P, head, tail) is True:
        return 1
    else:
        return 0

def path_except():
    return {'p':0}

# Example code
def example(dim, size):
    # Multidimensional lattice
    L = QNET.multidim_lattice(dim=dim, size=size, e=1, f=0.9, periodic=False)

    # head_tail method
    def get_ht(dim, size, G):
        head_string = "("
        tail_string = "("

        i = 0
        while i < dim:
            head_string += "0"
            tail_string += str(size-1)
            i += 1
            if i < dim:
                head_string += ", "
                tail_string += ", "
        head_string += ")"
        tail_string += ")"

        def corner_head_tail(G):
            head = G.getNode(head_string)
            tail = G.getNode(tail_string)
            return head, tail

        return corner_head_tail

    # Head tail method
    corner_head_tail = get_ht(dim, size, L)

    # List of protocols
    protocols = [QNET.path_exist, QNET.best_costs, QNET.simple_purify]

    # Keyword arguments for protocols
    p_kwargs = [{}, {}, {"threshold":10}]

    # Exception methods for protocols
    e_methods = [path_except, None, None]

    # Get cost array
    cost_array = monte_method(protocols,
                              corner_head_tail, L, num_iters=1000, num_steps=20,
                              protocol_kwargs=p_kwargs, exception_methods=e_methods)

    # Plot cost array
    plot_monte_method(cost_array, protocols=protocols,
                      title=f"Graph of Different Protocol Costs Against a {size}^{dim} Lattice")

example(dim = 3, size = 3)