"""
23/06/20
Monte Carlo methods for testing single and multi-user protocols
@author Hudson Leone
"""

import QNET
import networkx as nx
import numpy as np
import random
import matplotlib.pyplot as plt
import statistics as stats
import scipy.stats as sp
import copy


def percolate(Q, prob, head_tail_method):
    """
    Percolates a graph with some probability, making sure not to remove particular nodes of interest (head, tail)
    :param Q: Qnet Graph
    :param prob: Probability of not removing a given node not in (head, tail)
    :param head: Qnode
    :param tail: Qnode
    :return: Percolated Graph, head node, tail node
    """
    C = copy.deepcopy(Q)
    head, tail = head_tail_method(C)

    kill_list = []
    for node in C.nodes():
        xd = random.uniform(0,1)
        if xd < prob:
            if node not in (head, tail):
                kill_list.append(node)
    C.remove_nodes_from(kill_list)
    return C, head, tail


def monte_method(protocols, head_tail_method, Q, num_iters, num_steps, protocol_kwargs = None, exception_methods = None):
    """
    This function runs a list of protocols against multiples instances of pseudo-random graphs and returns the costs for
    each. The graphs are generated by taking graph Q as an input and randomly percolating it over a range of percolation
    densities. Nodes specified by the head_tail_method are not removed with this method. Once the data is collected,
    it's then processed such that for each protocol and percolation density there's an associated mean and variance.
    Users wishing to visualise this output may do so with plot_monte_method.

    In the event that a path does not exist between the head and tail, no data is added, unless an exception method is
    specified. In the event that only 0 or 1 data point was collected, (Hence either mean or variance is not well
    defined) then the mean and variance are set to zero.

    monte_method supports the testing of single and multi party algorithms. Simply design your protocols and
    head_tail_method such that they return and accept lists of head and tail nodes respectively

    :param list protocols:
    A list of functions that will be used on the percolated graphs. They must each have the following form:
    function(Q, head, tail, **kwargs)
    Where Q is a Qnet graph, and head and tail are either two nodes in Q or two equal-length lists containing nodes
    in Q.

    :param head_tail_method:
    This is a method for generating communication parties over which the protocol will take place. It must be of the
    following form:

    function(Q)
    Where is Q is a Qnet graph

    It must return either two nodes or two equal-length lists of nodes.

    :param Q: The Qnet graph to be percolated
    :param int num_iters: Number of iterations per percolation density
    :param int num_steps: Number of steps in over the percolation density range (0,1)

    :param list protocol_kwargs:
    Optional: A list of dictionaries containing additional keyword arguments for each of the protocols. Hint: Use an
    empty dictionary for protocols that don't have additional kwargs.

    :param list exception_methods:
    Optional: A list of methods for each protocol that handle the event in which no path was found. If method is None,
    only data points from graphs where head and tail are connected are used.

    :return: A two dimensional cost array. The first index is the protocol used, the second is the percolation density.
    Each value is a tuple containing the mean and variance:

    cost_array[protocol_index][percolation_index] = (mean, variance)

    Function Outline:
    1. Percolate lattice
    2. Check that path exists from A to B
    3. Run protocol
    4. Collect data
    5. Repeat until num_iters is reached
    6. Repeat for all protocols
    7. Process data into mean and varience
    """
    if protocol_kwargs is not None:
        assert(len(protocols) == len(protocol_kwargs))

    if exception_methods is not None:
        assert(len(protocols) == len(exception_methods))

    # Range of percolation densities to calculate for
    defect_probs = np.linspace(0, 1, num_steps)

    # Initalize 2d lattice of methods and costs
    cost_array = [[[] for i in range(num_steps)] for j in range(len(protocols))]

    prob_index = 0
    for prob in defect_probs:
        for i in range(num_iters):
            # Percolate the graph and get head and tail node
            P, head, tail = QNET.percolate(Q, prob, head_tail_method)
            assert head is not None and tail is not None
            # If head_tail method returns lists of nodes, check they're the same size
            if isinstance(head, list) or isinstance(tail, list):
                assert len(head) == len(tail)
            if nx.has_path(P, head, tail):
                method_index = 0
                for protocol in protocols:
                    # Get protocol kwargs
                    if protocol_kwargs is not None:
                        kwargs = protocol_kwargs[method_index]
                    else:
                        kwargs = {}
                    cost = protocol(P, head, tail, **kwargs)
                    cost_array[method_index][prob_index].append(cost)
                    method_index += 1
            # Else if no path exists between head and tail:
            else:
                if exception_methods is not None:
                    # Run exception_methods for costs
                    method_index = 0
                    for method in exception_methods:
                        if method is not None:
                            cost = method()
                            cost_array[method_index][prob_index].append(cost)
                        method_index += 1

        prob_index += 1

    # Before cost array is returned, process the data into (mean, var) form
    processed_array = [[[] for i in range(num_steps)] for j in range(len(protocols))]

    for i in range(len(protocols)):
        for j in range(num_steps):
            # Except cases where mean and variance are not well defined
            if len(cost_array[i][j]) in [0, 1]:
                mean = 0
                err = 0
            else:
                #mean = sum(cost_array[i][j]) / num_iters
                mean = stats.mean(cost_array[i][j])
                # Get standard error
                err = sp.sem(cost_array[i][j])
            processed_array[i][j].append(mean)
            processed_array[i][j].append(err)

    return processed_array


# Do we want this to be a function? We could probably just get away with plotting
def plot_monte_method(cost_array, title, method_labels):
    num_steps = len(cost_array[0])
    defect_prob = np.linspace(0, 1, num_steps)  # Range over which Monte-Carlo Iterations runs

    proto_index = 0
    for protocol in cost_array:
        avg = []
        err = []
        for data in cost_array[proto_index]:
            avg.append(data[0])
            err.append(data[1])

        plt.title(title)
        plt.xlabel("Node Deletion Probability")
        plt.ylabel("Protocol Cost")
        plt.errorbar(defect_prob, avg, yerr=err, label=method_labels[proto_index])
        plt.legend()
        proto_index += 1
    plt.show()


# New multi-dimensional array
def multidim_lattice(dim, size, e, p, periodic=False):
    dim = [size]*dim
    print(dim)
    G = nx.grid_graph(dim, periodic)

    Q = QNET.Qnet()
    for edge in G.edges():
        u = edge[0]
        v = edge[1]
        Q.add_qchan(edge=[u, v], e=e, p=p)
    return Q


# Some functions to test out monte_method
def simple_head_tail(P):
    A = P.getNode("A")
    B = P.getNode("B")
    return A, B

def simple_protocol(P, head, tail):
    return QNET.simple_purify(P, head, tail, threshold=10)

def path_exist(P, head, tail):
    if nx.has_path(P, head, tail) is True:
        return 1
    else:
        return 0

def path_except():
    return 0

def best_fidelity(P, head, tail):
    return QNET.best_path_cost(P, head, tail, cost_type = 'p')


# Example
def example(dim, size):
    # Keyword arguments for protocols
    p_kwargs = [{}, {}, {"threshold": 10}]

    # Exception methods for protocols
    e_methods = [path_except, None, None]

    # Multidimensional lattice
    L = multidim_lattice(dim=dim, size=size, e=1, p=0.9, periodic=False)

    # head_tail method
    def get_ht(dim, size, G):
        head_string = "("
        tail_string = "("

        i = 0
        while i < dim:
            head_string += "0"
            tail_string += str(size-1)
            i += 1
            if i < dim:
                head_string += ", "
                tail_string += ", "
        head_string += ")"
        tail_string += ")"

        def corner_head_tail(G):
            head = G.getNode(head_string)
            tail = G.getNode(tail_string)
            return head, tail

        return corner_head_tail

    corner_head_tail = get_ht(dim, size, L)

    # Get cost array
    cost_array = monte_method([path_exist, best_fidelity, QNET.simple_purify],
                              corner_head_tail, L, num_iters=500, num_steps=20,
                              protocol_kwargs=p_kwargs, exception_methods=e_methods)

    # Plot cost array
    plot_monte_method(cost_array, title=f"Graph of different protocols against {size}^{dim} percolated graphs",
                      method_labels=["path_exist", "best_fidelity", "simple_protocol"])

# example(dim = 3, size = 3)